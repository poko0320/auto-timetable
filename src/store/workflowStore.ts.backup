import { create } from 'zustand';
import { 
  Node, 
  Edge, 
  addEdge, 
  applyNodeChanges, 
  applyEdgeChanges,
  NodeChange,
  EdgeChange,
  Connection
} from 'reactflow';
import { NodeData, ExecutionLog, WorkflowExecution, NodeType, NodeStatus } from '../types';
import { NODE_REGISTRY } from '../processors';
import { WorkflowEngine } from '../engine/WorkflowEngine';
import { WorkflowStorage, WorkflowData } from '../utils/workflowStorage';

interface WorkflowStore {
  // Workflow state
  nodes: Node<NodeData>[];
  edges: Edge[];
  isExecuting: boolean;
  executionLogs: ExecutionLog[];
  lastExecution?: WorkflowExecution;
  
  // Workflow metadata
  currentWorkflowId: string | null;
  workflowName: string;
  workflowDescription: string;
  
  // UI state
  selectedNodeId: string | null;
  isPropertiesPanelOpen: boolean;
  isChatPanelOpen: boolean;
  
  // Workflow actions
  setNodes: (nodes: Node<NodeData>[]) => void;
  setEdges: (edges: Edge[]) => void;
  onNodesChange: (changes: NodeChange[]) => void;
  onEdgesChange: (changes: EdgeChange[]) => void;
  onConnect: (connection: Connection) => void;
  
  // Node management
  addNode: (type: NodeType, position: { x: number; y: number }) => void;
  updateNodeConfig: (nodeId: string, config: any) => void;
  updateNodeLabel: (nodeId: string, label: string) => void;
  deleteNode: (nodeId: string) => void;
  duplicateNode: (nodeId: string) => void;
  
  // Execution
  executeWorkflow: () => Promise<void>;
  stopExecution: () => void;
  clearLogs: () => void;
  
  // Save/Load functionality
  saveWorkflow: (name?: string, description?: string) => WorkflowData;
  loadWorkflow: (id: string) => void;
  newWorkflow: () => void;
  exportWorkflow: () => void;
  importWorkflow: () => Promise<void>;
  
  // UI actions
  selectNode: (nodeId: string | null) => void;
  togglePropertiesPanel: () => void;
  toggleChatPanel: () => void;
}

const workflowEngine = new WorkflowEngine();

export const useWorkflowStore = create<WorkflowStore>((set, get) => ({
  // Initial state
  nodes: [],
  edges: [],
  isExecuting: false,
  executionLogs: [],
  lastExecution: undefined,
  
  // Workflow metadata
  currentWorkflowId: null,
  workflowName: 'Untitled Workflow',
  workflowDescription: '',
  
  // UI state
  selectedNodeId: null,
  isPropertiesPanelOpen: false,
  isChatPanelOpen: false,
      type: 'smoothstep',
      animated: true
    },
    {
      id: 'e2-3',
      source: '2',
      target: '3',
      type: 'smoothstep',
      animated: true
    }
  ],
  isExecuting: false,
  executionLogs: [],
  selectedNodeId: null,
  isPropertiesPanelOpen: false,
  isChatPanelOpen: false,

  // Actions
  setNodes: (nodes) => set({ nodes }),
  setEdges: (edges) => set({ edges }),
  
  onNodesChange: (changes) => {
    set({
      nodes: applyNodeChanges(changes, get().nodes)
    });
  },
  
  onEdgesChange: (changes) => {
    set({
      edges: applyEdgeChanges(changes, get().edges)
    });
  },
  
  onConnect: (connection) => {
    set({
      edges: addEdge({
        ...connection,
        type: 'smoothstep',
        animated: true
      }, get().edges)
    });
  },
  
  addNode: (type, position) => {
    const nodeDefinition = NODE_REGISTRY[type];
    if (!nodeDefinition) return;
    
    const newNode: Node<NodeData> = {
      id: `node_${Date.now()}`,
      type: 'custom',
      position,
      data: {
        label: nodeDefinition.label,
        type: nodeDefinition.type,
        category: nodeDefinition.category,
        status: 'idle',
        config: { ...nodeDefinition.defaultConfig }
      }
    };
    
    set({
      nodes: [...get().nodes, newNode]
    });
  },
  
  updateNodeConfig: (nodeId, config) => {
    set({
      nodes: get().nodes.map(node => 
        node.id === nodeId 
          ? {
              ...node,
              data: {
                ...node.data,
                config: { ...node.data?.config, ...config }
              }
            }
          : node
      )
    });
  },
  
  updateNodeLabel: (nodeId, label) => {
    set({
      nodes: get().nodes.map(node => 
        node.id === nodeId 
          ? {
              ...node,
              data: {
                ...node.data,
                label
              }
            }
          : node
      )
    });
  },
  
  deleteNode: (nodeId) => {
    set({
      nodes: get().nodes.filter(node => node.id !== nodeId),
      edges: get().edges.filter(edge => 
        edge.source !== nodeId && edge.target !== nodeId
      ),
      selectedNodeId: get().selectedNodeId === nodeId ? null : get().selectedNodeId
    });
  },
  
  duplicateNode: (nodeId) => {
    const node = get().nodes.find(n => n.id === nodeId);
    if (!node) return;
    
    const newNode: Node<NodeData> = {
      ...node,
      id: `node_${Date.now()}`,
      position: {
        x: node.position.x + 50,
        y: node.position.y + 50
      }
    };
    
    set({
      nodes: [...get().nodes, newNode]
    });
  },
  
  executeWorkflow: async () => {
    const { nodes, edges } = get();
    
    set({ 
      isExecuting: true, 
      executionLogs: [],
      nodes: nodes.map(node => ({
        ...node,
        data: { ...node.data, status: 'idle' as const }
      }))
    });
    
    try {
      const execution = await workflowEngine.executeWorkflow(nodes, edges);
      
      // Update node statuses based on execution results
      const updatedNodes = nodes.map(node => {
        const result = execution.nodeResults[node.id];
        const status: NodeStatus = result ? (result.success ? 'success' : 'error') : 'idle';
        
        return {
          ...node,
          data: {
            ...node.data,
            status,
            lastExecution: result ? {
              timestamp: new Date(),
              duration: result.metadata?.executionTime || 0,
              success: result.success,
              error: result.error
            } : undefined
          }
        };
      });
      
      set({
        nodes: updatedNodes,
        lastExecution: execution,
        executionLogs: workflowEngine.getExecutionLogs(),
        isExecuting: false
      });
      
    } catch (error) {
      set({
        isExecuting: false,
        executionLogs: workflowEngine.getExecutionLogs()
      });
    }
  },
  
  stopExecution: () => {
    set({ isExecuting: false });
  },
  
  clearLogs: () => {
    workflowEngine.clearLogs();
    set({ executionLogs: [] });
  },
  
  selectNode: (nodeId) => set({ selectedNodeId: nodeId }),
  
  togglePropertiesPanel: () => set((state) => ({ 
    isPropertiesPanelOpen: !state.isPropertiesPanelOpen 
  })),
  
  toggleChatPanel: () => set((state) => ({ 
    isChatPanelOpen: !state.isChatPanelOpen 
  }))
}));